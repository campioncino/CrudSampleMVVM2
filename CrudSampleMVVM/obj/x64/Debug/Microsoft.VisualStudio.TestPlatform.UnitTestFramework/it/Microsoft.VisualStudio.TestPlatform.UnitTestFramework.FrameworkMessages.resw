<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ElementNumbersDontMatch" xml:space="preserve">
    <value>Il numero di elementi nelle raccolte non corrisponde. Previsto:&lt;{1}&gt;. Effettivo:&lt;{2}&gt;.{0}</value>
  </data>
  <data name="IsMatchFail" xml:space="preserve">
    <value>La stringa '{0}' non corrisponde al modello '{1}'. {2}.</value>
  </data>
  <data name="IsInstanceOfFailMsg" xml:space="preserve">
    <value>{0} Tipo previsto:&lt;{1}&gt;. Tipo effettivo:&lt;{2}&gt;.</value>
  </data>
  <data name="ContainsFail" xml:space="preserve">
    <value>La stringa '{0}' non contiene la stringa '{1}'. {2}.</value>
  </data>
  <data name="InternalObjectNotValid" xml:space="preserve">
    <value>L'oggetto interno a cui si fa riferimento non è più valido.</value>
  </data>
  <data name="StartsWithFail" xml:space="preserve">
    <value>La stringa '{0}' non inizia con la stringa '{1}'. {2}.</value>
  </data>
  <data name="AreEqualDifferentTypesFailMsg" xml:space="preserve">
    <value>Previsto:&lt;{1} ({2})&gt;. Effettivo:&lt;{3} ({4})&gt;. {0}</value>
  </data>
  <data name="BothSameElements" xml:space="preserve">
    <value>Le due raccolte contengono gli stessi elementi. {0}</value>
  </data>
  <data name="InvalidParameterToAssert" xml:space="preserve">
    <value>Parametro '{0}' non valido. {1}.</value>
  </data>
  <data name="AreNotEqualDeltaFailMsg" xml:space="preserve">
    <value>Prevista una differenza maggiore di &lt;{3}&gt; tra il valore previsto &lt;{1}&gt; e il valore effettivo &lt;{2}&gt;. {0}</value>
  </data>
  <data name="ElementsAtIndexDontMatch" xml:space="preserve">
    <value>Elemento nell'indice {0} non corrispondente.</value>
  </data>
  <data name="BothCollectionsSameReference" xml:space="preserve">
    <value>Entrambi i riferimenti a raccolte puntano allo stesso oggetto Collection. {0}</value>
  </data>
  <data name="PrivateAccessorConstructorNotFound" xml:space="preserve">
    <value>
      Impossibile trovare il costruttore con la firma specificata. Potrebbe essere necessario rigenerare la funzione di accesso privata
      oppure il membro potrebbe essere privato e definito su una classe base. In quest'ultimo caso, è necessario passare il tipo
      che definisce il membro nel costruttore di PrivateObject.
    </value>
  </data>
  <data name="AssertionFailed" xml:space="preserve">
    <value>{0} non riuscito. {1}</value>
  </data>
  <data name="DoNotUseAssertEquals" xml:space="preserve">
    <value>&amp;Impossibile utilizzare Assert.Equals per le asserzioni. Utilizzare Assert.AreEqual e gli overload.</value>
  </data>
  <data name="UTF_TestMethodNoExceptionDefault" xml:space="preserve">
    <value>Il metodo di test {0}.{1} non ha generato un'eccezione. È prevista un'eccezione dall'attributo {2} definito nel metodo di test.</value>
  </data>
  <data name="Common_NullInMessages" xml:space="preserve">
    <value>(null)</value>
  </data>
  <data name="UTF_TestMethodWrongExceptionDerivedAllowed" xml:space="preserve">
    <value>Il metodo di test {0}.{1} ha generato l'eccezione {2}, ma era prevista l'eccezione {3} o un tipo derivato da essa. Messaggio dell'eccezione: {4}</value>
  </data>
  <data name="ElementTypesAtIndexDontMatch2" xml:space="preserve">
    <value>L'elemento nell'indice {1} è (null). Tipo previsto:&lt;{2}&gt;.{0}</value>
  </data>
  <data name="NoExceptionThrown" xml:space="preserve">
    <value>Nessuna eccezione generata. Era prevista un'eccezione {1}. {0}</value>
  </data>
  <data name="NoDataRow" xml:space="preserve">
    <value>Nessun DataRowAttribute specificato. È necessario almeno un DataRowAttribute con DataTestMethodAttribute.</value>
  </data>
  <data name="CollectionEqualReason" xml:space="preserve">
    <value>{0}({1})</value>
  </data>
  <data name="EqualsTesterInvalidArgs" xml:space="preserve">
    <value>Argomento non valido: EqualsTester non può utilizzare valori null.</value>
  </data>
  <data name="AccessStringInvalidSyntax" xml:space="preserve">
    <value>Sintassi non valida della stringa di accesso.</value>
  </data>
  <data name="ElementTypesAtIndexDontMatch" xml:space="preserve">
    <value>L'elemento nell'indice {1} non è del tipo previsto. Tipo previsto:&lt;{2}&gt;. Tipo effettivo:&lt;{3}&gt;.{0}</value>
  </data>
  <data name="ErrorInvalidCast" xml:space="preserve">
    <value>Impossibile convertire un oggetto di tipo {0} in {1}.</value>
  </data>
  <data name="AreNotEqualFailMsg" xml:space="preserve">
    <value>Previsto qualsiasi valore tranne:&lt;{1}&gt;. Effettivo:&lt;{2}&gt;. {0}</value>
  </data>
  <data name="UTF_TestMethodNoException" xml:space="preserve">
    <value>Il metodo di test {0}.{1} non ha generato l'eccezione prevista {2}. {3}</value>
  </data>
  <data name="IsNotMatchFail" xml:space="preserve">
    <value>La stringa '{0}' corrisponde al modello '{1}'. {2}.</value>
  </data>
  <data name="UTF_TestMethodWrongException" xml:space="preserve">
    <value>Il metodo di test {0}.{1} ha generato l'eccezione {2}, ma era prevista l'eccezione {3}. Messaggio dell'eccezione: {4}</value>
  </data>
  <data name="WrongExceptionThrown" xml:space="preserve">
    <value>Generata eccezione {2}, ma era prevista un'eccezione {1}. {0}
Messaggio eccezione: {3}
Analisi dello stack: {4}</value>
  </data>
  <data name="IsNotInstanceOfFailMsg" xml:space="preserve">
    <value>Tipo errato:&lt;{1}&gt;. Tipo effettivo:&lt;{2}&gt;. {0}</value>
  </data>
  <data name="AreEqualDeltaFailMsg" xml:space="preserve">
    <value>Prevista una differenza non maggiore di &lt;{3}&gt; tra il valore previsto &lt;{1}&gt; e il valore effettivo &lt;{2}&gt;. {0}</value>
  </data>
  <data name="UTF_FailedToGetExceptionMessage" xml:space="preserve">
    <value>(Impossibile ottenere il messaggio per un'eccezione di tipo {0} a causa di un'eccezione.)</value>
  </data>
  <data name="AllItemsAreUniqueFailMsg" xml:space="preserve">
    <value>Rilevato elemento duplicato:&lt;{1}&gt;. {0}</value>
  </data>
  <data name="Common_ObjectString" xml:space="preserve">
    <value>(oggetto)</value>
  </data>
  <data name="EndsWithFail" xml:space="preserve">
    <value>La stringa '{0}' non termina con la stringa '{1}'. {2}.</value>
  </data>
  <data name="NumberOfElementsDiff" xml:space="preserve">
    <value>Numero differente di elementi.</value>
  </data>
  <data name="NullParameterToAssert" xml:space="preserve">
    <value>Parametro '{0}' non valido. Il valore non può essere null. {1}.</value>
  </data>
  <data name="BothCollectionsSameElements" xml:space="preserve">
    <value>Le due raccolte contengono gli stessi elementi.</value>
  </data>
  <data name="BothCollectionsEmpty" xml:space="preserve">
    <value>Le due raccolte sono vuote. {0}</value>
  </data>
  <data name="AreEqualCaseFailMsg" xml:space="preserve">
    <value>Previsto:&lt;{1}&gt;. La combinazione di maiuscole e minuscole è diversa per il valore effettivo:&lt;{2}&gt;. {0}</value>
  </data>
  <data name="InvalidPropertyType" xml:space="preserve">
    <value>Proprietà {0} con tipo {1}. Tipo previsto {2}.</value>
  </data>
  <data name="AreSameGivenValues" xml:space="preserve">
    <value>Non passare tipi di valore a AreSame(). I valori convertiti in Object non saranno mai uguali. Utilizzare AreEqual(). {0}</value>
  </data>
  <data name="UTF_ExpectedExceptionTypeMustDeriveFromException" xml:space="preserve">
    <value>Il tipo di eccezione previsto deve essere System.Exception o un tipo derivato da System.Exception.</value>
  </data>
  <data name="AreEqualFailMsg" xml:space="preserve">
    <value>Previsto:&lt;{1}&gt;. Effettivo:&lt;{2}&gt;. {0}</value>
  </data>
  <data name="ActualHasMismatchedElements" xml:space="preserve">
    <value>La raccolta prevista contiene {1} occorrenza/e di &lt;{2}&gt;. La raccolta effettiva contiene {3} occorrenza/e. {0}</value>
  </data>
  <data name="PrivateAccessorMemberNotFound" xml:space="preserve">
    <value>
      Impossibile trovare il membro ({0}) specificato. Potrebbe essere necessario rigenerare la funzione di accesso privata
      oppure il membro potrebbe essere privato e definito su una classe base. In quest'ultimo caso, è necessario passare il tipo
      che definisce il membro nel costruttore di PrivateObject.
    </value>
  </data>
</root>